<div id="notas" class="animated fadeIn">

  <h2>Componentes</h2>

  <app-indice [items]="itemsIndice"></app-indice>
  
  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="introduccion">1. Introducción</h3>
  <hr>

  <ul>
    <li>Grosso modo, un componente es una clase asociada a un decorador que cumple un rol específico dentro de nuestra aplicación</li>
    <li>Lo deseable es crear componentes para bloques de código de cierta complejidad o susceptibles de repetirse en más de una página, como sucede por ejemplo con el menú de navegación o el pie de página, entre otros</li>
    <li>De esta forma, cada bloque de código afectado por su correspondiente componente <u>queda encapsulado</u>, mejorando además la modularidad de nuestro proyecto</li>
    <li>Un componente por defecto se compone de un fichero HTML o template, una hoja de estilos, un fichero de pruebas y un fichero TS, donde <u>solo este último es obligatorio</u></li>
    
  </ul>

  <h4>1.1 Componente principal</h4>

  <ul>
    <li>En Angular existe un componente principal cuyo selector es <b>&lt;app-root&gt;</b></li>
    <li>Este componente es el padre de todos los componentes que pudiéramos crear por nuestra cuenta</li>
    <li>Se renderiza en el fichero <i>index.html</i> y <u>solo debe renderizarse ahí</u> (no debemos utilizar este selector en ningún otro fichero HTML porque dará error)</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="decorador">2. Decorador</h3>
  <hr>

  <ul>
      <li>El decorador de un componente es una extensión de la clase <b>Component</b> que sirve para <u>dotar de identidad única</u> al componente</li>
      <li>Este se compone de una serie de campos que sirven para asignar a un componente un selector, un fichero HTML y una hoja de estilos a través de sus campos (figura 1.1)</li>
      <li>Como vemos en la figura 1.1, <u>solo el selector es obligatorio</u>, los otros dos campos, así como sus ficheros, se pueden suprimir si no nos hicieran falta</li>
      <li>Eso sí, si eliminásemos cualquiera de estos dos ficheros, habría que eliminar también el campo o los campos correspondientes del decorador para que no dé error</li>
  
      <img src="assets/img/componentes/figura1-1.png" alt="">
      <caption><strong>Figura 1.1.</strong> Diferentes configuraciones para el decorador de un componente</caption>
  
      <li>Cuando la plantilla HTML o la hoja de estilos sea demasiado simple, tenemos la opción de escribir el código directamente dentro el campo correspondiente del decorador en lugar de utilizar un fichero aparte (figura 1.2)</li>
      <li>Este es el motivo por el que solo el fichero TS es indispensable para trabajar con un componente, dado que el decorador puede albergar el contenido de los otros dos ficheros</li>

      <img src="assets/img/componentes/figura1-2.png" alt="">
      <caption><strong>Figura 1.2.</strong> Código HTML y hoja de estilos embebidos dentro del campo del decorador de un componente</caption>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="crear-componente">2. Crear componente</h3>
  <hr>

  <ul>
    <li>Para crear un componente dentro del directorio <i>app</i>, ejecutamos el comando <b>$ ng generate component _Nombre del componente_</b> o <b>$ ng g c _Nombre del componente_</b></li>
    <li>Es una buena práctica crear todos los componentes dentro de un mismo directorio (por ejemplo, <i>components</i> o <i>componentes</i>) para separarlos de los demás tipos de elementos</li>
    <li>Para ello, escribiemos el prefijo de ruta delante del nombre del componente, de la forma <b>$ ng g c componentes/_Nombre del componente_</b></li>
    <li>Como vemos, no es necesario escribir la ruta completa para el prefijo de ruta, sino la ruta a partir del directorio <i>app</i></li>
    <li>También es una buena práctica meter dentro de un directorio (por ejemplo, <i>shared</i> o <i>compartido</i>) aquellos componentes compartidos, como el menú de navegación o el pie de página, entre otros</li>
  </ul>

  <h4>2.1 Eliminar uno o más ficheros opcionales</h4>

  <ul>
    <li>Con ficheros opcionales nos referimos a los ficheros que no son indispensables para el correcto funcionamiento de un componente, es decir, todos menos el fichero TS</li>
    <li>Podemos eliminar cada uno de ellos manualmente, pero si se tratase del fichero HTML o de la hoja de estilos, recuerda actualizar también el campo correspondiente del decorador</li>
    <li>Con actualizar nos referimos a eliminar la ruta del campo del decorador, ya que apuntaría a un fichero inexistente</li>
    <li>A partir de aquí podemos dejar ese campo vacío (escribiendo <b>[&nbsp;]</b>), eliminarlo o embeber dentro del código HTML o CSS correspondiente</li>
    <li>Ojo, el fichero de pruebas (de extensión <i>.spec.ts</i>) se puede eliminar sin más, dado que no le corresponde ningún campo del decorador</li>
  </ul>

  <h4>2.2 Omitir la creación de uno o más ficheros secundarios mediante flags</h4>

  <ul>
    <li>En lugar de eliminar manualmente los ficheros secundarios de un componente, podemos ahorrarnos este proceso diciéndole a Angular CLI que no los cree cuando creamos un componente desde la consola mediante flags</li>
    <li>Para crear un componente sin fichero HTML, ejecutamos el comando <b>$ ng g c _Nombre del componente_ -it</b> (<b>it</b> de inline template)</li>
    <li>Para crear un componente sin hoja de estilos, ejecutamos el comando <b>$ ng g c _Nombre del componente_ -is</b> (<b>is</b> de inline styles)</li>
    <li>Para crear un componente sin fichero de pruebas, ejecutamos el comando <b>$ ng g c _Nombre del componente_ --skipTests</b></li>
    <li>Para crear un componente sin directorio propio, ejecutamos el comando <b>$ ng g c _Nombre del componente_ --flat</b></li>
    <li>Podemos utilizar más de un flag si quisiéramos, incluso todos ellos, quedando <b>$ ng g c _Nombre del componente_ --flat -it -is --skipTests</b></li>
  </ul>

  <h4>2.3 Actualizar el fichero <i>app.module.ts</i></h4>

  <ul>
    <li>Tras crear un componente es necesario actualizar el fichero <i>app.module.ts</i> para dejar constancia de la existencia de dicho componente dentro del proyecto (esa es la función principal de los módulos)</li>
    <li>No obstante, Angular CLI actualiza este módulo automáticamente y nos notifica de ello por consola tras completarse la creación (figura 2.1)</li>

    <img src="assets/img/componentes/figura2-1.png" alt="">
    <caption><strong>Figura 2.1.</strong> Notificación de Angular CLI de que el fichero <i>app.module.ts</i> ha sido actualizado</caption>

    <li>No obstante, si esto no llegara a ocurrir, conviene saber cómo actualizarlo por nosotros mismos</li>
    <li>Para ello, tenemos que importar el componente y escribir el nombre de su clase dentro del campo <b>declarations</b> del decorador</li>
    <li>También conviene verificar que la palabra reservada <b>export</b> se encuentre delante del nombre de clase de nuestro componente, justo delante de la palabra reservada <b>class</b></li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="eliminar-componente">3. Eliminar componente</h3>
  <hr>

  <ul>
    <li>Primero debemos eliminar su directorio, así como todos los ficheros que pudiera contener</li>
    <li>Tras esto, actualizamos el fichero <i>app.module.ts</i>, eliminando la instrucción <b>import</b> asociada, así como el nombre de clase del componente dentro campo <b>declarations</b> del decorador</li>
    <li>Finalmente, actualizamos el fichero <i>app.routes.ts</i>, eliminando la instrucción <b>import</b> asociada, así como el mapping entre la ruta y el componente, en caso de existir, dentro de la constante <b>APP_ROUTES</b></li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="modificar-componente">4. Modificar componente</h3>
  <hr>

  <h4>4.1 Cambiar ubicación de un componente</h4>

  <ul>
    <li>Para cambiar un componente de sitio, podemos utilizar la consola, el editor de código (recomendado) o el explorador de archivos</li>
    <li>Tras esto, actualizamos los ficheros <i>app.module.ts</i> y <i>app.routes.ts</i> manualmente, concretamente las instrucciones <b>import</b></li>
  </ul>

  <h4>4.2 Cambiar nombre de clase de un componente</h4>

  <ul>
    <li>Actualizamos los ficheros <i>app.module.ts</i> y <i>app.routes.ts</i> manualmente, concretamente las instrucciones <b>import</b></li>
    <li>Además, tendremos que actualizar esta en el campo <b>declarations</b> del decorador del fichero <i>app.module.ts</i> y el mapping del fichero <i>app.routes.ts</i></li>
  </ul>

  <h4>4.3 Cambiar selector de un componente</h4>

  <ul>
    <li>Para cambiar el selector de un componente, debemos modificar el literal asociado al campo <b>selector</b> del decorador</li>
    <li>Tras esto, actualizamos el selector en cada uno de los ficheros HTML donde hayamos renderizado el componente, sin tocar los ficheros <i>app.module.ts</i> ni <i>app.routes.ts</i></li>
    <li>Nótese que Angular pone el prefijo <i>app</i> en el selector del componente automáticamente, pero podemos quitarlo y poner el identificador que queramos</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="renderizar-componente">5. Renderizar componente</h3>
  <hr>

  <ul>
    <li>Para renderizar un componente basta con escribir su selector dentro del fichero HTML de uno o más componentes</li>
  </ul>
  
  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="enviar-parametro">6. Enviar parámetros desde un componente padre a un componente hijo</h3>
  <hr>

   <ul>
    <li>Es posible enviar parámetros desde un componente (componente padre) a otro (componente hijo)</li>
    <li>El envío de parámetros se efectúa desde el fichero HTML, escribéndolos dentro del selector del componente, siguiendo una sintaxis similar a los atributos de HTML (figura 6.1)</li>
    <li>Como se observa en la digura 6.1, si el valor del parámetro se obtiene de una variable TS del componente padre, wrappeamos el nombre del atributo con corchetes, no siendo necesario en caso de transferir un literal</li>

    <img src="assets/img/componentes/figura6-1.png" alt="">
    <caption><strong>Figura 6.1.</strong> Envío de parámetros desde el componente padre al componente hijo</caption>
    
    <li>Para poder recibir y utilizar estos parámetros en el componente hijo, tenemos que importar la clase <b>Input</b> en el fichero TS del mismo</li>
    <li>A partir de ahora podremos crear tantos atributos como deseemos declarando variables dentro de la clase del componente hijo como hemos hecho siempre (figura 6.2)</li>
    <li>La única diferencia es que debemos escribir el decorador <b>@Input()</b> delante del identificador de la variable para indicarle a Angular que esta recibirá su valor del componente padre</li>
    <li>No obstante, es posible inicializar un parámetro y darle un valor por defecto en caso de que el componente padre no transfiera nada (no escribiendo el atributo dentro del selector)</li>
    
    <img src="assets/img/componentes/figura6-2.png" alt="">
    <caption><strong>Figura 6.2.</strong> Declaración de parámetros de entrada</caption>

    <li>En el ejemplo ilustrado en la figura 6.2 es necesario utilizar el decorador <b>@Input()</b> incluso para el segundo parámetro, que transfiere un literal</li>
    <li>Claro, aunque se transfiera un literal, para utilizar el valor del segundo parámetro debemos almacenarlo en una variable TS mediante este decorador</li>

    <img src="assets/img/componentes/figura6-3.png" alt="">
    <caption><strong>Figura 6.3.</strong> Mapping entre parámetro y variable cuando los identificadores no coinciden</caption>

    <li>Como ilustra la figura 6.2, el nombre del atributo y el nombre de la variable coinciden, pero no es obligatorio</li>
    <li>Es posible asignarle un identificador diferente a la variable, en cuyo caso debemos escribir el identificador del atributo dentro del decorador para que sepa con qué variable se va realizar el mapeo (figura 6.3)</li>
    <li>No obstante, no se considera una buena práctica (de hecho, es posible que TS dé error), ya que estamos utilizando dos identificadores distintos para hacer referencia a lo mismo, lo que puede resultar confuso</li>

  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="enviar-evento">7. Enviar evento desde un componente hijo a un componente padre</h3>
  <hr>

  <div class="consultar">Consultar <a href="https://www.youtube.com/watch?v=WhUIY_458Yk"       target="_blank">enlace</a></div>
  <div class="consultar mb-40">Consultar <a href="https://www.youtube.com/watch?v=hNLDU9B3Ssk" target="_blank">enlace</a></div>

  <ul>
    <li>Es posible enviar información al revés que como vimos en el apartado anterior, esto es, desde un componente padre a un componente hijo</li>
    <li>Esta comunicación, como veremos a continuación, no se va a establecer mediante el envío de parámetors, sino a través de eventos</li>
    <li>Utilizamos esta técnica cuando tenemos varios componentes hijos repetidos (por ejemplo, debido a la directiva <b>*ngFor</b>) y deseamos interactuar con uno de ellos y saber de todos con cuál estamos interactuando</li>
  </ul>

  <h4>7.1 Ejemplos ilustrativos</h4>
  
  <ul>
    <li>Supongamos que tenemos un grid de noticias que se renderiza en el componente padre en la que cada una es un componente (el componente hijo) con un identificador</li>
    <li>Si el usuario hiciera clic en una noticia cualquiera, deseamos que este acceda a una página con toda la información de la noticia seleccionada</li>
    <li>Para saber en qué tarjeta hemos hecho clic para poder renderizar la información correspondiente, necesitamos su identificador, lo que se puede conseguir gracias a esta técnica</li>
    <li>No obstante, esto mismo se puede conseguir trabajando con rutas, embebiendo el identificador del elemento seleccionado como parámetro de la URL</li>
    <li>Supongamos ahora un panel de administración con un listado de usuarios a modo de tabla, en la que para cada fila tenemos un botón para eliminar para dar de baja al usuario correspondiente</li>
    <li>Cuando hagamos clic en un botón cualquiera, ¿cómo podemos saber qué usuario fue el que seleccionamos? Pues a partir de esta técnica</li>
  </ul>

  <h4>7.2 Modificaciones en el fichero TS del componente hijo</h4>

  <ul>
    <li>Importamos las clases <b>Output</b> y <b>EventEmitter</b></li>
    <li>Para declarar el evento que deseemos que el componente padre esté escuchando, debemos utilizar el decorador <b>@Output()</b> antes de escribir el identificador del mismo (figura 7.1)</li>
    <li>Este evento, que no es más que un observable, debe ser de tipo <b>EventEmitter&lt;_Tipo_&gt;</b>, indicando entre paréntesis angulares el tipo devuelto por el manejador</li>
    <li>Tiene sentido, dado que vamos a implementar <u>un evento que emita información</u> al componente padre, teniendo que indicar el tipo de la información que deseamos enviar</li>

    <img src="assets/img/componentes/figura7-1.png" alt="">
    <caption><strong>Figura 7.1.</strong> Declaración del observable</caption>

    <li>Tras esto, debemos instanciar este nuevo evento que acabamos de crear dentro del cuerpo del constructor (figura 7.2)</li>

    <img src="assets/img/componentes/figura7-2.png" alt="">
    <caption><strong>Figura 7.2.</strong> Instancia del observable</caption>

    <li>Posteriormente creamos, un método que dispare este evento devolviendo la información deseada (figura 7.3)</li>
    <li>Nótese que en el ejemplo ilustrado en la figura 7.3 hemos enviado un literal, pero bien podría haber sido un caso más sofisticado, como una expresión, la propiedad de un objeto, etc.</li>

    <img src="assets/img/componentes/figura7-3.png" alt="">
    <caption><strong>Figura 7.3.</strong> Método que dispara el evento con la información que se desea transferir</caption>

    <h4>7.3 Modificaciones en el fichero HTML del componente padre</h4>
    
    <li>Por último, escribimos el selector del componente hijo con el identificador del observable a modo de parámetro entre paréntesis (figura 7.4)</li>
    <li>Claro, utilizamos paréntesis en lugar de corchetes, dado que <u>deseamos enviar o lanzar un evento</u> al componente hijo para que nos devuelva información</li>
    <li>Nótese que debemos declarar el método declarado en el componente hijo (figura 7.3) que emitía el evento en cuestión, enviándole un evento como parámetro (figura 7.4)</li>

    <img src="assets/img/componentes/figura7-4.png" alt="">
    <caption><strong>Figura 7.4.</strong> Captación de parámetros de salida desde el fichero HTML del componente padre</caption>

  </ul>
</div>