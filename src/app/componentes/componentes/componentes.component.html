<div id="notas" class="animated fadeIn">

  <h2>Componentes</h2>

  <app-indice [items]="itemsIndice"></app-indice>
  
  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="introduccion">1. Introducción</h3>
  <hr>

  <ul>
    <li>Grosso modo, un componente es una clase asociada a un decorador que cumple un rol específico dentro de nuestra aplicación</li>
    <li>Lo deseable es crear componentes para bloques de código de cierta complejidad o susceptibles de repetirse en más de una página, como sucede por ejemplo con el menú de navegación o el pie de página, entre otros</li>
    <li>De esta forma, cada bloque de código afectado por su correspondiente componente <u>queda encapsulado</u>, mejorando además la modularidad de nuestro proyecto</li>
    <li>Un componente por defecto se compone de un fichero HTML o template, una hoja de estilos, un fichero de pruebas y un fichero TS, donde <u>solo este último es obligatorio</u></li>
    
  </ul>

  <h4>1.1 Componente principal</h4>

  <ul>
    <li>En Angular existe un componente principal cuyo selector es <b>&lt;app-root&gt;</b></li>
    <li>Este componente es el padre de todos los componentes que pudiéramos crear por nuestra cuenta</li>
    <li>Se renderiza en el fichero <i>index.html</i> y <u>solo debe renderizarse ahí</u> (no debemos utilizar este selector en ningún otro fichero HTML porque dará error)</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="decorador">2. Decorador</h3>
  <hr>

  <ul>
      <li>El decorador de un componente es una extensión de la clase <b>Component</b> que sirve para <u>dotar de identidad única</u> al componente</li>
      <li>Este se compone de una serie de campos que sirven para asignar a un componente un selector, un fichero HTML y una hoja de estilos a través de sus campos (figura 1.1)</li>
      <li>Como vemos en la figura 1.1, <u>solo el selector es obligatorio</u>, los otros dos campos, así como sus ficheros, se pueden suprimir si no nos hicieran falta</li>
      <li>Eso sí, si eliminásemos cualquiera de estos dos ficheros, habría que eliminar también el campo o los campos correspondientes del decorador para que no dé error</li>
  
      <img src="assets/img/componentes/figura1-1.png" alt="">
      <caption><strong>Figura 1.1.</strong> Diferentes configuraciones para el decorador de un componente</caption>
  
      <li>Cuando la plantilla HTML o la hoja de estilos sea demasiado simple, tenemos la opción de escribir el código directamente dentro el campo correspondiente del decorador en lugar de utilizar un fichero aparte (figura 1.2)</li>
      <li>Este es el motivo por el que solo el fichero TS es indispensable para trabajar con un componente, dado que el decorador puede albergar el contenido de los otros dos ficheros</li>

      <img src="assets/img/componentes/figura1-2.png" alt="">
      <caption><strong>Figura 1.2.</strong> Código HTML y hoja de estilos embebidos dentro del campo del decorador de un componente</caption>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="crear-componente">2. Crear componente</h3>
  <hr>

  <ul>
    <li>Para crear un componente dentro del directorio <i>app</i>, ejecutamos el comando <b>$ ng generate component _Nombre del componente_</b> o <b>$ ng g c _Nombre del componente_</b></li>
    <li>Es una buena práctica crear todos los componentes dentro de un mismo directorio (por ejemplo, <i>components</i> o <i>componentes</i>) para separarlos de los demás tipos de elementos</li>
    <li>Para ello, escribiemos el prefijo de ruta delante del nombre del componente, de la forma <b>$ ng g c componentes/_Nombre del componente_</b></li>
    <li>Como vemos, no es necesario escribir la ruta completa para el prefijo de ruta, sino la ruta a partir del directorio <i>app</i></li>
    <li>También es una buena práctica meter dentro de un directorio (por ejemplo, <i>shared</i> o <i>compartido</i>) aquellos componentes compartidos, como el menú de navegación o el pie de página, entre otros</li>
  </ul>

  <h4>2.1 Eliminar uno o más ficheros opcionales</h4>

  <ul>
    <li>Con ficheros opcionales nos referimos a los ficheros que no son indispensables para el correcto funcionamiento de un componente, es decir, todos menos el fichero TS</li>
    <li>Podemos eliminar cada uno de ellos manualmente, pero si se tratase del fichero HTML o de la hoja de estilos, recuerda actualizar también el campo correspondiente del decorador</li>
    <li>Con actualizar nos referimos a eliminar la ruta del campo del decorador, ya que apuntaría a un fichero inexistente</li>
    <li>A partir de aquí podemos dejar ese campo vacío (escribiendo <b>[&nbsp;]</b>), eliminarlo o embeber dentro del código HTML o CSS correspondiente</li>
    <li>Ojo, el fichero de pruebas (de extensión <i>.spec.ts</i>) se puede eliminar sin más, dado que no le corresponde ningún campo del decorador</li>
  </ul>

  <h4>2.2 Omitir la creación de uno o más ficheros secundarios mediante flags</h4>

  <ul>
    <li>En lugar de eliminar manualmente los ficheros secundarios de un componente, podemos ahorrarnos este proceso diciéndole a Angular CLI que no los cree cuando creamos un componente desde la consola mediante flags</li>
    <li>Para crear un componente sin fichero HTML, ejecutamos el comando <b>$ ng g c _Nombre del componente_ -it</b> (<b>it</b> de inline template)</li>
    <li>Para crear un componente sin hoja de estilos, ejecutamos el comando <b>$ ng g c _Nombre del componente_ -is</b> (<b>is</b> de inline styles)</li>
    <li>Para crear un componente sin fichero de pruebas, ejecutamos el comando <b>$ ng g c _Nombre del componente_ --skipTests</b></li>
    <li>Para crear un componente sin directorio propio, ejecutamos el comando <b>$ ng g c _Nombre del componente_ --flat</b></li>
    <li>Podemos utilizar más de un flag si quisiéramos, incluso todos ellos, quedando <b>$ ng g c _Nombre del componente_ --flat -it -is --skipTests</b></li>
  </ul>

  <h4>2.3 Actualizar el fichero <i>app.module.ts</i></h4>

  <ul>
    <li>Tras crear un componente es necesario actualizar el fichero <i>app.module.ts</i> para dejar constancia de la existencia de dicho componente dentro del proyecto (esa es la función principal de los módulos)</li>
    <li>No obstante, Angular CLI actualiza este módulo automáticamente y nos notifica de ello por consola tras completarse la creación (figura 2.1)</li>

    <img src="assets/img/componentes/figura2-1.png" alt="">
    <caption><strong>Figura 2.1.</strong> Notificación de Angular CLI de que el fichero <i>app.module.ts</i> ha sido actualizado</caption>

    <li>No obstante, si esto no llegara a ocurrir, conviene saber cómo actualizarlo por nosotros mismos</li>
    <li>Para ello, tenemos que importar el componente y escribir el nombre de su clase dentro del campo <b>declarations</b> del decorador</li>
    <li>También conviene verificar que la palabra reservada <b>export</b> se encuentre delante del nombre de clase de nuestro componente, justo delante de la palabra reservada <b>class</b></li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="eliminar-componente">3. Eliminar componente</h3>
  <hr>

  <ul>
    <li>Primero debemos eliminar su directorio, así como todos los ficheros que pudiera contener</li>
    <li>Tras esto, actualizamos el fichero <i>app.module.ts</i>, eliminando la instrucción <b>import</b> asociada, así como el nombre de clase del componente dentro campo <b>declarations</b> del decorador</li>
    <li>Finalmente, actualizamos el fichero <i>app.routes.ts</i>, eliminando la instrucción <b>import</b> asociada, así como el mapping entre la ruta y el componente, en caso de existir, dentro de la constante <b>APP_ROUTES</b></li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="modificar-componente">4. Modificar componente</h3>
  <hr>

  <h4>4.1 Cambiar ubicación de un componente</h4>

  <ul>
    <li>Para cambiar un componente de sitio, podemos utilizar la consola, el editor de código (recomendado) o el explorador de archivos</li>
    <li>Tras esto, actualizamos los ficheros <i>app.module.ts</i> y <i>app.routes.ts</i> manualmente, concretamente las instrucciones <b>import</b></li>
  </ul>

  <h4>4.2 Cambiar nombre de clase de un componente</h4>

  <ul>
    <li>Actualizamos los ficheros <i>app.module.ts</i> y <i>app.routes.ts</i> manualmente, concretamente las instrucciones <b>import</b></li>
    <li>Además, tendremos que actualizar esta en el campo <b>declarations</b> del decorador del fichero <i>app.module.ts</i> y el mapping del fichero <i>app.routes.ts</i></li>
  </ul>

  <h4>4.3 Cambiar selector de un componente</h4>

  <ul>
    <li>Para cambiar el selector de un componente, debemos modificar el literal asociado al campo <b>selector</b> del decorador</li>
    <li>Tras esto, actualizamos el selector en cada uno de los ficheros HTML donde hayamos renderizado el componente, sin tocar los ficheros <i>app.module.ts</i> ni <i>app.routes.ts</i></li>
    <li>Nótese que Angular pone el prefijo <i>app</i> en el selector del componente automáticamente, pero podemos quitarlo y poner el identificador que queramos</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="renderizar-componente">5. Renderizar componente</h3>
  <hr>

  <ul>
    <li>Para renderizar un componente basta con escribir su selector dentro del fichero HTML de uno o más componentes</li>
  </ul>
  
  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 id="enviar-parametro">6. Enviar parámetros desde un componente padre a un componente hijo</h3>
  <hr>

   <ul>
    <li>Es posible enviar parámetros desde un componente (componente padre) a otro (componente hijo)</li>
    <li>El envío de parámetros se efectúa desde el fichero HTML, escribéndolos dentro del selector del componente, siguiendo una sintaxis similar a los atributos de HTML (figura 6.1)</li>
    <li>Como se observa en la digura 6.1, si el valor del parámetro se obtiene de una variable TS del componente padre, wrappeamos el nombre del atributo con corchetes, no siendo necesario en caso de transferir un literal</li>

    <img src="assets/img/componentes/figura6-1.png" alt="">
    <caption><strong>Figura 6.1.</strong> Envío de parámetros desde el componente padre al componente hijo</caption>
    
    <li>Para poder recibir y utilizar estos parámetros en el componente hijo, tenemos que importar la clase <b>Input</b> en el fichero TS del mismo</li>
    <li>A partir de ahora podremos crear tantos atributos como deseemos declarando variables dentro de la clase del componente hijo como hemos hecho siempre (figura 6.2)</li>
    <li>La única diferencia es que debemos escribir el decorador <b>@Input()</b> delante del identificador de la variable para indicarle a Angular que esta recibirá su valor del componente padre</li>
    <li>No obstante, es posible inicializar un parámetro y darle un valor por defecto en caso de que el componente padre no transfiera nada (no escribiendo el atributo dentro del selector)</li>
    
    <img src="assets/img/componentes/figura6-2.png" alt="">
    <caption><strong>Figura 6.2.</strong> Declaración de parámetros de entrada</caption>

    <li>En el ejemplo ilustrado en la figura 6.2 es necesario utilizar el decorador <b>@Input()</b> incluso para el segundo parámetro, que transfiere un literal</li>
    <li>Claro, aunque se transfiera un literal, para utilizar el valor del segundo parámetro debemos almacenarlo en una variable TS mediante este decorador</li>

    <img src="assets/img/componentes/figura6-3.png" alt="">
    <caption><strong>Figura 6.3.</strong> Mapping entre parámetro y variable cuando los identificadores no coinciden</caption>

    <li>Como ilustra la figura 6.2, el nombre del atributo y el nombre de la variable coinciden, pero no es obligatorio</li>
    <li>Es posible asignarle un identificador diferente a la variable, en cuyo caso debemos escribir el identificador del atributo dentro del decorador para que sepa con qué variable se va realizar el mapeo (figura 6.3)</li>
    <li>No obstante, no se considera una buena práctica (de hecho, es posible que TS dé error), ya que estamos utilizando dos identificadores distintos para hacer referencia a lo mismo, lo que puede resultar confuso</li>

  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 [id]="itemsIndice[7].enlace">7. {{ itemsIndice[7].texto }}</h3>
  <hr>

  <div class="consultar">Consultar <a href="https://www.youtube.com/watch?v=WhUIY_458Yk"       target="_blank">enlace</a></div>
  <div class="consultar mb-40">Consultar <a href="https://www.youtube.com/watch?v=hNLDU9B3Ssk" target="_blank">enlace</a></div>

  <h4>7.1 Modificaciones en el fichero TS del componente hijo</h4>

  <ul>
    <li>Importamos las clases <b>Output</b> y <b>EventEmitter</b></li>
    <li>Declaramos una variable de tipo <b>EventEmitter&lt;_Tipo_&gt;</b> utilizando el decorador <b>@Output()</b></li>
    <li>Si no deseamos especificar un tipo en concreto, podemos utilizar el tipo <b>any</b></li>
    <li>Dentro del constructor instanciamos este evento que acabamos de declarar</li>

    <img src="assets/img/componentes/figura7-1.png" alt="">
    <caption><strong>Figura 7.1.</strong> Declaración e instancia del emisor de evento</caption>

    <li>Posteriormente creamos un método que dispare este evento enviando la información deseada al componente padre (figura 7.2)</li>
    <li>No solo es posible enviar un literal a modo de parámetro, hubiera sido posible enviar una variable, una expresión, un array, un objeto, la propiedad de un objeto, etc.</li>
    <li>Como es obvio, este método se dispara desde el fichero HTML del componente hijo (por ejemplo, <b>(click)="abrirNoticia( noticia.id )"</b>)</li>

    <img src="assets/img/componentes/figura7-2.png" alt="">
    <caption><strong>Figura 7.2.</strong> Método que dispara el evento en el componente padre con la información que se desea transferir a modo de parámetro</caption>
  </ul>

  <h4>7.2 Modificaciones en el fichero HTML del componente padre</h4>

  <ul>
    <li>Escribimos el selector del componente hijo con el <u>mismo identificador</u> del <b>EventEmitter</b> que creamos en el componente hijo entre paréntesis (figura 7.3)</li>
    <li>Claro, utilizamos paréntesis en lugar de corchetes porque vamos a ejecutar un método cuando se dispare el evento que creamos en el componente hijo</li>
    <li>Esto es similar al clásico evento <b>(click)</b>, que ejecutará un manejador al hacer click, solo que en este caso el evento lo hemos creado nosotros</li>
    <li>Para el parámetro del manejador del evento debemos utilizar <b>$event</b>, que contendrá el valor del parámetro enviado desde el componente hijo</li>

    <img src="assets/img/componentes/figura7-3.png" alt="">
    <caption><strong>Figura 7.3.</strong> Evento y manejador de dicho evento</caption>
  </ul>

  <h4>7.3 Modificaciones en el fichero TS del componente padre</h4>

  <ul>

    <li>Creamos el manejador de este evento creado en el componente hijo para realizar las gestiones necesarias</li>
    <li>En el ejemplo de la figura 7.4 simplemente notificamos al usuario de la noticia que ha seleccionado</li>
    <li>Nótese que el identificador del parámetro del manejador no se <b>$event</b>, sino el identificador que nosotros queramos (aunque fuera <b>$event</b> en el fichero HTML)</li>

    <img src="assets/img/componentes/figura7-4.png" alt="">
    <caption><strong>Figura 7.4.</strong> Manejador del evento creado en el componente hijo</caption>
  </ul>

  <h4>7.4 Aclaraciones</h4>

  <ul>
    <li>La variable que declaramos e instanciamos dentro del fichero TS del componente hijo es de tipo <b>EventEmitter</b> porque vamos a emitir un evento <u>en el componente padre</u></li>
    <li>Cuando se dispare dicho evento, el componente padre lo detectará y ejecutará un método para gestionar la información enviada desde el componente hijo a modo de parámetro</li>
    <li>Es necesario especificar un tipo porque cuando disparemos el evento en el componente padre, este evento contendrá parámetros, que son información que deseamos que el componente padre reciba</li>
    <li>Este modo de comunicación es últil, por ejemplo, cuando un componente hijo se va a renderizar n veces mediante una directiva <b>*ngFor</b></li>
  </ul>
  
  <h4>7.5 Ejemplo ilustrativo 1</h4>
  
  <ul>
    <li>Supón que tenemos un panel de administración de usuarios donde cada usuario es un componente que renderiza toda la información de un usuario</li>
    <li>Para cada usuario tenemos la opción de eliminarlo del sistema, pero si eliminamos un usuario, ¿cómo sabe el componente padre de qué usuario se trata?</li>
    <li>Gracias a <b>EventEmitter</b> podemos disparar el método para eliminarlo en el componente desde el componente hijo (el usuario) padre enviándole el ID del usuario correspondiente</li>
    <li>En el componente padre, una vez se dispare el evento, se ejecuta un método que elimina el usuario y refresca el panel de administración para que este deje de aparecer renderizado</li>
    <li>Es posible implementar la eliminación desde el componente hijo (el de usuario), pero de ser así, tras eliminarlo, ¿cómo refrescarías la tabla para que este deje de aparecer renderizado?</li>
  </ul>

  <h4>7.6 Ejemplo ilustrativo 2</h4>
  
  <ul>
    <li>Supón que tenemos un grid de noticias donde cada noticia es un componente que renderiza el título de la noticia, un extracto y un enlace para ver la noticia completa</li>
    <li>Si el usuario hiciera clic en una noticia cualquiera, debería acceder a una página con toda la información de la noticia seleccionada</li>
    <li>Para saber qué noticia debemos abrir, podemos utilizar un <b>EventEmitter</b> para que el padre reciba el ID de la noticia correspondiente y la abra eventualmente</li>
    <li>No obstante, esto mismo se puede conseguir trabajando con rutas, embebiendo el identificador del elemento seleccionado como parámetro de la URL</li>
    <li>Este ejemplo ilustra dos formas distintas de hacer lo mismo, elige la que más se adecúe con tu forma de trabajar</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 [id]="itemsIndice[8].enlace">8. {{ itemsIndice[8].texto }}</h3>
  <hr>

  <div class="consultar mb-40">Consultar <a href="https://medium.com/@pandukamuditha/angular-5-share-data-between-sibling-components-using-eventemitter-8ebb49b64a0a" target="_blank">enlace</a></div>

  <ul>
    <li>Es posible que más de un componente hijo dispare el manejador en el componente padre antes el mismo evento, aunque este se lance desde diferentes componentes hermanos</li>
    <li>Para ello, sigue los pasos del apartado anterior para cada componente hermano</li>
    <li>Eso sí, la situación de la figura 7.3 se daría para cada componente hijo</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 [id]="itemsIndice[9].enlace">9. ViewChild</h3>
  <hr>

  <h4>9.1 Modificaciones en el fichero HTML del componente padre</h4>

  <ul>
    <li>Escribimos el identificador de la template reference variable en un elemento HTML o en el selector de un componente hijo</li>

    <img src="assets/img/componentes/figura9-1.png" alt="">
    <caption><strong>Figura 9.1.</strong> Template referenes variables para ambos casos</caption>
  </ul>

  <h4>9.2 Modificaciones en el fichero TS del componente padre</h4>

  <div class="consultar mb-40">Consultar <a href="https://www.youtube.com/watch?v=AyuIaJTqBLs" target="_blank">enlace</a></div>

  <ul>
    <li>Importamos la clase <b>ViewChild</b></li>
    <li>Declaramos una variable con total normalidad, escribiendo su identificador y especificando su tipo, pero utilizando el prefijo <b>@ViewChild()</b></li>
    <li>Dentro de este prefijo debemos enviar dos parámetros (figura 9.2)</li>
    <li>Como vemos, el primer parámetro es el identificador de la template reference variable (figura 9.1)</li>
    <li>El segundo parámetro indica si el elemento HTML o el componente hijo en cuestión es estático (valor <b>true</b>) o no (valor <b>false</b>)</li>
    <li>Grosso modo, cuando es estático siempre se mostrará, no depende de ninguna directiva <b>*ngIf</b> ni nada de por el estilo</li>

    <img src="assets/img/componentes/figura9-2.png" alt="">
    <caption><strong>Figura 9.2.</strong> Declaración de variables con <b>@ViewChild()</b></caption>

    <li>A partir de ahora, desde este fichero podremos acceder a las propiedades del componente hijo a partir de la variable que acabamos de declarar (figura 9.2)</li>
    <li>Asimismo, podremos disparar sus métodos, incluso cuando se trate de inyecciones</li>
  </ul>

  <h4>9.3 Aclaraciones</h4>

  <ul>
    <li><b>@ViewChild()</b> nos permite acceder a los atributos de un componente hijo, así como disparar sus métodos desde el componente padre</li>
    <li>También se presenta como una alternativa a las herramientas ofrecidas por JavaScript o jQuery para manejar un elemento HTML desde el fichero TS del componente en cuestión</li>
  </ul>

  <h4>9.4 Ejemplo ilustrativo</h4>

  <ul>
    <li>Supón que tenemos un grid de noticias donde cada noticia es un componente que renderiza el título de la noticia, un extracto y un enlace para ver la noticia completa</li>
    <li>Si el usuario hiciera clic en una noticia cualquiera, debería abrir un modal de forma suavizada con toda la información de la noticia seleccionada</li>
    <li>Para conseguir este propósito (el efecto suavizado), debemos modificar los estilos del componente hijo (el modal)</li>
    <li>Para ello, cuando el usuario selecciona una noticia en cuestión, dispararemos el método que abre el modal en el componente hijo desde el componente padre</li>
    <li>Desde el método del componente hijo podremos modificar los estilos del modal para que aparezca de manera suavizada</li>
  </ul>

</div>