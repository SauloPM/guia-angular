<div id="notas" class="animated fadeIn">

  <h2>TypeScript</h2>

  <app-indice [items]="itemsIndice"></app-indice>

  <h3 id="proposito">1. Propósito</h3>
  <hr>

  <ul>
    <li>En el <u>código de JS</u> de la figura 1 tenemos la declaración de una función que utiliza un parámetro de entrada para imprimir un saludo por consola, una declaración de objeto y una invocación a esta función, respectivamente</li>
    <li>El resultado no va a ser el esperado, dado que para que tenga sentido, la función debería recibir un parámetro de tipo <b>string</b> y le estamos enviando un objeto</li>
    <li>A priori no tenemos modo alguno de darnos cuenta de nuestro error hasta en el momento de su ejecución, analizando el resultado en la consola de JS del navegador web, que mostraría el mensaje <i>Hola, [object Object]</i></li>
    
    <img src="assets/img/typescript/figura1.png" alt="">
    <caption><strong>Figura 1.</strong> Código JS para imprimir un saludo por consola</caption>
    
    <li>Recordemos que en JS no se especifica el tipo de los parámetros en la declaraciónde una función, de modo que no tenemos medios suficientes para ser alertados por el compilador</li>
    <li>Es más, si lo hiciéramos, es probable que apareciera resalado a modo de error (figura 2), dado que para poder especificar el tipo en la declaración de parámetros hemos de utilizar TS</li>

    <img src="assets/img/typescript/figura2.png" alt="">
    <caption><strong>Figura 3.</strong> Mensaje de error al especificar el tipo de un parámetro</caption>

    <li>Si ejecutásemos el código de la figura 2 en TS, seríamos alertados por el compilador, como se observa en la figura 3, en el que el mensaje de error nos indica la incompatibilidad debido precisamente al tipado entre los parámetros actuales y formales</li>
    <li>Ojo, a pesar de alertarnos en TS, si el código <u>no contiene ningún error de JS, se ejecutará sin problemas</u> (lo peor que puede pasar es que el resultado no sea el esperado)</li>
    <li>Es decir, que aunque asuste la aparición de advertencias de errores al pasar de JS a TS, el compilador no nos impide ejecutar nuestro código, al contrario que en otros lenguajes de programación</li>
    <li>No debemos asustarnos a la hora de utilizar TS tras ver tanta notificación de error, dado que se trata de una herramienta que nos ayuda a darnos cuenta de nuestras meteduras de pata antes de la ejecución</li>
    <li>¿Qué ventajas ofrece? Muchas. Por ejemplo, la detección de errores resulta muchísimo más sencilla gracias a estas notificaciones. No tenemos que estar sacando conclusiones a partir de un resultado no deseado, sobre todo si no se produce ningún mensaje de error en la consola, lo que a veces nos puede llevar muchísimo tiempo</li>
    <li>Ten en cuenta que nuestro código de JS puede estar mal aunque no se muestre ningún error en la consola del navegador web si el resultado es erróneo, en cuyo caso no tendríamos pista alguna de por qué las cosas no han salido como planeábamos</li>

    <img src="assets/img/typescript/figura3.png" alt="">
    <caption><strong>Figura 3.</strong> Código de la figura 2 en TS</caption>

    <li>La figura 4 ilustra el código equivalente en TS, en el que se especifica el tipo del parámetro de la función y se envía el campo <i>nombre</i> del objeto, en lugar del objeto completo, obteniendo el resultado esperado: <i>Hola, John</i></li>
    <li>En resumen, TS es un súper conjunto de TS porque lo enriquece, nos alerta de posibles <u>errores antes de la ejecución</u>, ofrece mayor robustez debido al tipado de datos, entre otros, lo que asciende a JS al mismo nivel que otros lenguajes de programación</li>

    <img src="assets/img/typescript/figura4.png" alt="">
    <caption><strong>Figura 4.</strong> Código TS para imprimir un saludo por consola</caption>

    <h4>1.1 TS versus JS</h4>

    <ul>
      <li>En JS no se conoce el tipo de una variable hasta que es inicializada</li>
      <li>Por si fuera poco, una misma variable puede cambiar de tipo si se inicializa a literales de diferente tipo, lo que puede resultar caótico y poco robusto</li>
      <li>En JS la notificación de errores se produce en tiempo de ejecución, en la consola del navegador web, pero no antes, como ocurre con TS</li>
      <li>Esto da pie a multitud de errores que podrían ser detectados a tiempo y que son difíciles de detectar tras la ejecución</li>
      <li>Algunos de estos errores podrían ser variables no definidas, mapeo incoherente entre las propiedades de objetos, erratas en la escritura de identificadores, persistencia de código obsoleto de JS en la caché del navegador, colisión de código, etc.</li>
      <li>Dado que TS es un súper conjunto de JS, este es 100% compatible con el primero, con lo que podremos utilizar JS en TS sin ningún problema</li>
      <li>El código en JS tiende a ser mucho más complejo que el código en TS equivalente</li>
      <li>De esta forma, el propósito de TS es ayudarnos a cometer la menos cantidad de errores posible</li>
    </ul>

  </ul>

  <h3 id="configuracion">2. Configuración</h3>
  <hr>

  <ul>
    <li>El fichero <i>tsconfig.json</i> nos permite configurar o establecer nuevas reglas para el compilador de TS</li>
    <li>Sí, en el momento de ejecución no trabajamos con TS, sino con JS compilado, dado que el navegador web no es capaz de interpretar código TS, sino JS</li>
    <li>En la figura 5 se ilustra el contenido por defecto de este fichero en un proyecto de Angular</li>

    <img src="assets/img/typescript/figura5.png" alt="">
    <caption><strong>Figura 5.</strong> Contenido por defecto del fichero <i>tsconfig.json</i> en un proyecto de Angular</caption>

    <li>El campo <b>target</b> es la versión de JS a la que deseamos compilar nuestro código de TS (en el ejemplo de la figura 5 es ECMAScript 5)</li>
    <li>El campo <b>sourceMap</b> activa o desactiva la generación de ficheros de soporte para depuración de código</li>
  </ul>

  <h3 id="variables">3. Variables</h3>
  <hr>

  <h4>3.1 Declaración de variables con <b>var</b> y <b>let</b></h4>

  <ul>
    <li>El código de la figura 6 mostrará por consola el mensaje <i>Adiós, mundo</i></li>
    <li>Dentro de la sentencia condicional, aunque estemos declarando la variable nuevamente, se considera la misma al tener el mismo identificador que la anterior</li>

    <img src="assets/img/typescript/figura6.png" alt="">
    <caption><strong>Figura 6.</strong> Declaración de variables con <b>var</b></caption>

    <li>Por el contrario, el código de la figura 7 mostrará por consola el mensaje <i>Hola, mundo</i></li>
    <li>¿Por qué? Porque con <b>let</b> cada variable es distinta, aunque compartan el mismo identificador, dado que en la segunda declaración, la variable solo tiene repercusión dentro del ámbito de la sentencia condicional</li>
    <li>De hecho, si inspeccionáramos el código compilado a JS, veríamos que el compilador generó el alias <i>saludo_1</i> para la segunda declaración</li>
    <li>El motivo reside en que los ámbitos de estas declaraciones son diferentes. El de la primera declaración afecta a todo el cuerpo del algoritmo, mientras que el de la segunda afecta solo a la sentencia condicional</li>
    
    <img src="assets/img/typescript/figura7.png" alt="">
    <caption><strong>Figura 7.</strong> Declaración de variables con <b>let</b></caption>

    <li>No obstante, si ambas declaraciones estuvieran <u>dentro del mismo ámbito</u> (es decir, en el mismo nivel), TS mostraría un mensaje de error</li>
    <li>De ahora en adelante utilizaremos <b>let</b> en lugar de <b>var</b> en TS, dado que el primero ofrece un mejor control sobre el ámbito que el segundo</li>
  </ul>

  <h4>3.2 Constantes</h4>

  <ul>
    <li>Para declarar constantes debemos utilizar la palabra reservada <b>const</b> en lugar de <b>let</b></li>
    <li>Es un estándar que los identificadores de las constantes se escriban en mayúsculas</li>
    <li>Estas deben ser inicializadas en el momento de su declaración</li>
    <li>Tras esto no podremos variar su valor, dado que son de solo lectura</li>
    <li>No obstante, al igual que como ocurría en la figura 6, si declaramos dos constantes con el mismo identificador, pero en ámbitos diferentes, no habría problema</li>
    <li>Claro, se compilarían a JS con identificadores distintos a modo de alias, como ocurría en la figura 7</li>
  </ul>

  <h4>3.3 Inicialización de variables</h4>

  <ul>

    <img src="assets/img/typescript/figura8.png" alt="">
    <caption><strong>Figura 8.</strong> Declaración e inicialización de variables en TS</caption>

    <li>Por lo general, en TS debemos indicar el tipo de una variable en el momento de su declaración (figura 8)</li>
    <li>No obstante, si esta se inicializa en el momento de su declaración, podremos omitir su tipo, dado que con el literal resultaría evidente</li>
    <li>Ojo, si omitimos el tipo en la declaración de una variable debido a que la hemos inicializado, igualmente se debe respetar en futuras reasignaciones</li>
    <li>Es decir, no podremos asignarle un literal numérico a una vairable inicializada como cadena de caracteres, aunque omitiéramos el tipo en el momento de su declaración</li>
    <li>Ojo, cuando decimos que algo no se puede, en realidad no es del todo cierto necesariamente. TS dará un mensaje de error, pero <u>es posible</u> que el código JS resultante no dé errores en el navegador web</li>
  </ul>

  <h4>3.4 Tipo especial <b>any</b></h4>

  <ul>
    <li>El tipado de TS otorga de robustez a JS, pero es una pena haber perdido la flexibilidad que nos brindaba JS a la hora de poder almacenar en una misma variable literales de diferente tipo</li>
    <li>Esta flexibilidad se mantiene en TS con el tipo <b>any</b> (figura 8), que nos permite utilizar variables en TS con la misma libertad que ofrecía JS por defecto con cualquier variable</li>
  </ul>

  <h4>3.5 Objetos</h4>

  <ul>

    <img src="assets/img/typescript/figura9.png" alt="">
    <caption><strong>Figura 9.</strong> Declaración de objetos en TS</caption>

    <li>Tras declarar un objeto mediante su inicialización (figura 9), TS generará automáticamente un tipo personalizado de variables</li>
    <li>¿Qué significa eso? Que si utilizáramos este mismo objeto y lo asignáramos a otro objeto, tendríamos que respetar su estructura interna</li>
    <li>Obivamente, es posible cambiar una propiedad en particular mediante el operador punto</li>
    <li>En el último caso ilustrado en la figura 9, vemos cómo reasignamos el objeto <i>heroe</i>, pero incorporando una nueva propiedad llamada <i>alias</i></li>
    <li>Dado que dicha propiedad no se especificó en el momento de la declaración de este objeto, dará error</li>
  </ul>

  <h3 id="interpolacion">4. Plantillas de interpolación de literales de tipo <b>string</b></h3>
  <hr>

  <ul>

    <img src="assets/img/typescript/figura10.png" alt="">
    <caption><strong>Figura 10.</strong> Diferentes formas de trabajar con literales <b>string</b> en TS</caption>

    <li>En la figura 10 vemos diferentes maneras de operar con literales <b>string</b>, siendo especialmente interesante cuando se incluyen variables</li>
    <li>Como vemos, la manera convencional de mezclar literales <b>string</b> y variables puede volverse extremadamente laboriosa, como se observa en el caso 4 de de esta figura</li>
    <li>Como alternativa se nos ofrece el operador <b>$&#123; _Expresión_ &#125;</b>, conocido como interpolación que, combinado con los caracteres <i>`</i> (no confundir con los apóstrofes convencionales), nos permiten trabajar mezclando literales <b>string</b> y variables de una forma más cómoda y compacta, como ilustra el caso 5 de la figura 10</li>
    <li>Esta técnica se conoce como plantillas de interpolación de literales de tipo <b>string</b> o template string interpolation en inglés</li>

    <img src="assets/img/typescript/figura11.png" alt="">
    <caption><strong>Figura 11.</strong> Interpolación y saltos de línea</caption>

    <li>Otra ventaja de esta forma de operar es que podemos añadir saltos de línea fácilmente, sin necesidad de escribir <i>\n</i>, como se observa en la figura 11</li>
    <li>No solo eso, sino que si imprimiéramos el valor de la variable <i>receta</i> por consola, veríamos que igualmente se respetarían los saltos de línea (figura 12)</li>
    <li>Imagina lo laborioso que sería conseguir eso mismo sin esta técnica: tendríamos que escribir <i>\n</i> para cada salto de línea e ir probando con los espacios para clavar la indentación</li>
    <li>El compilador se encargará de dejarlo de la manera convencional cuando compile a JS, librándonos a nosotros de esta tarea</li>

    <img src="assets/img/typescript/figura12.png" alt="">
    <caption><strong>Figura 12.</strong> Representación por consola del ejemplo ilustrado en la figura 11</caption>

    <li>Ojo, la interpolación no solo admite variables, también expresiones y en general cualquier código TS</li>
    <li>En el ejemplo de la figura 11 no hemos especificado el tipo de la variable receta, pero como la inicializamos a un literal de tipo <b>string</b>, no fue necesario, pero de haber querido especificar el tipo, este hubiera sido lógicamente <b>string</b></li>
  </ul>

  <h3 id="funciones">5. Funciones</h3>
  <hr>

  <div class="pendiente">Poner una ristra de parámetros opcionales, algunos de ellos con valores y otros sin nada, en plan desordenado, a ver si se lo traga</div>
  <div class="pendiente">Cambiar las figuras de abajo</div>
    
  <img src="assets/img/typescript/figura13.png" alt="">
  <caption><strong>Figura 13.</strong> Distintos casos de paso de parámetros</caption>
  
  <h4>5.1 Paso de parámetros</h4>
  
  <ul>
    <li>Hay diferentes formas de especificar los parámetros de una función, como se observa la figura 13</li>
    <li>En TS no está permitido declarar un parámetro sin tipo (parámetro <i>parametro1</i>), dado que para eso tenemos el tipo <b>any</b> (parámetro <i>parametro2</i>)</li>
    <li>Nótese que en la figura 13, TS nos está advirtiendo de que no está permitida la declaración de parámetros sin tipo (línea punteada debajo de <i>parametro1</i>)</li>
    <li>El parámetro <i>parametro3</i> es un caso completamente normal</li>
    <li>Tenemos dos parámetros opcionales, que son <i>parametro4</i>, en el que además se transfiere un vector, y <i>parametro7</i></li>
    <li>Los parámetros <i>parametro5</i> y <i>parametro6</i> tienen asignados un valor por defecto, y dado que su tipo se evidencia con el literal, no es necesario especificarlo explícitamente, como ocurre en el primer caso</li>
    <li>Los parámetros opcionales (<i>parametro4</i> y <i>parametro7</i>) no pueden preceder a parámetros obligatorios, a no ser que estos tengan un valor asignado por defecto, de ahí que no tengamos problemas porque el parámetro <i>parametro4</i> preceda a los dos siguientes</li>
  </ul>

  <h4>5.2 Invocación</h4>

  <ul>
    <li>Es una buena práctica que los parámetros opcionales vayan todos al final, uno detrás de otro, dejando los primeros puestos para los obligatorios</li>

    <img src="assets/img/typescript/figura14.png" alt="">
    <caption><strong>Figura 14.</strong> Invocación a la función de la figura 14</caption>

    <li>El motivo reside en el momento de la invocación, dado que en la figura 14 podemos ver en la tercera invocación que nos señala un error si dejamos el hueco del parámetro opcional vacío si después vienen otros parámetros, aunque estos tengan un valor por defecto</li>
    <li>En las dos primeras invocaciones hemos prescindido del último parámetro, dado que este es opcional, podemos no enviar nada (primera invocación) o dejarlo en blanco (segunda invocación)</li>
  </ul>

  <h4>5.3 Funciones flecha</h4>
  
  <div class="pendiente">Terminar sección a partir de las capturas (las tienes en el Gmail)</div>
  <div class="pendiente mb-40">Mirar vídeo a partir del minuto 7:00</div>

  <ul>
    <li>Una función flecha es una nueva característica del ES6</li>
    <li>Normalmente toda función convencional tiene su equivalente en función flecha y viceversa, pero a veces solo la función flecha puede ofrecernos una solución</li>
  </ul>

  <h3 id="desestructuracion">6. Desestructuración</h3>
  <hr>

  <ul>
    <li>En este apartado vamos a tratar la desestructuración de objetos y vectores utilizando ejemplos simples</li>
    <li>No obstante, es posible aplicar esta técnica en objetos o vectores anidados, también en vectores de objetos</li>
  </ul>

  <h4>6.1 Objetos</h4>

  <ul>
    <li>Dado un objeto, podemos almacenar el valor de sus campos o propiedades en variables aparte (figura 18)</li>
    <li>Como vemos, inicializamos un objeto llamado <i>persona</i>, posteriormente declaramos una variable por cada campo (les hemos puesto el mismo nombre) y luego imprimimos cada una de ellas por consola</li>

    <img src="assets/img/typescript/figura18.png" alt="">
    <caption><strong>Figura 18.</strong> Asignación entre variables y campos de un objeto</caption>
    
    <li>No obstante, el código de esta figura puede ser notablemente simplificado mediante desestructuración de objetos, como ilustra la figura 19</li>
    <li>Como vemos, hemos establecido un mapping entre las variables y los campos del objeto <u>a través de sus identificadores</u></li>
    
    <img src="assets/img/typescript/figura19.png" alt="">
    <caption><strong>Figura 19.</strong> Asignación entre variables y campos de un objeto mediante desestructuración</caption>
    
    <li>Esto implica que el orden en el que escribamos las variables dentro de la desestructuración de un objeto es irrelevante</li>
    <li>Claro, la asignación se rige por los identificadores, no por la posición de las variables dentro de la desestructuración</li>
    <li>En la figura 20 hemos cambiado el orden de las variables dentro de la desestructuración, pero la asignación se mantiene porque el orden no importa</li>
    <li>No obstante, de haber cambiado el nombre de algunas de las variables, siendo distinto al campo correspondiente del objeto, daría error, dado que los identificadores deben ser los mismos</li>

    <img src="assets/img/typescript/figura20.png" alt="">
    <caption><strong>Figura 20.</strong> Cambio del orden de las variables dentro de la desestructuración</caption>

    <li>En la figura 21 hemos especificado el tipo para uno de los campos de la desestructuración, pero como vemos, a la hora de imprimir por consola, daría error</li>
    <li>¿Por qué? Porque cuando especificamos el tipo en la desestructuración siguiendo esta sintaxis, la palabra reservada <b>string</b> no se interpreta como un tipo, sino como un alias</li>

    <img src="assets/img/typescript/figura21.png" alt="">
    <caption><strong>Figura 21.</strong> Especificación de tipos en la desestructuración de objetos</caption>

    <li>Esto explica que al imprimir el valor de estas variables por consola tengamos que escribir <b>string</b> en lugar del nombre del campo en cuestión, dado que <b>string</b> es el alias del campo (figura 22)</li>
    <li>Grosso modo, no debemos especificar el tipo dentro de una desestructuración porque estos serán interpretados como alias, no como tipos</li>
    <li>TS es capaz de suponer el tipo de una variable en una desestructuración en base a los literales asignados a las propiedades de nuestros objetos con los que se establece el mapping</li>

    <img src="assets/img/typescript/figura22.png" alt="">
    <caption><strong>Figura 22.</strong> Uso de alias en la desestructuración de objetos</caption>
  </ul>

  <h4>6.2 Vectores</h4>

  <ul>
    <li>La desestructuración en vectores sigue un esquema similar al de la figura 19, pero de manera más simple, como ilustra la figura 23</li>
    
    <img src="assets/img/typescript/figura23.png" alt="">
    <caption><strong>Figura 23.</strong> Asignación entre variables y campos de un vector mediante desestructuración</caption>
    
    <li>Nótese que al contrario que antes, en este caso <u>el orden sí importa</u>. De haber cambiado los nombres de lugar, el mapping cambiaría porque <u>ahora es secuencial</u> (figura 24)</li>
    <li>Claro, en un objeto cada campo tenía un identificador propio, pero en un vector solo tenemos literales, de modo que el único modo de establecer un mapping es mediante el orden</li>
    <li>Por este mismo motivo también es posible escribir identificadores distintos a nuestras variables</li>
    <li>Por ejemplo, en la figura 24 tenemos una variable de identificador <i>dni</i> que será mappeada con el literal <i>Arquitecto</i> al empatar en posición, aunque no tenga sentido</li>

    <img src="assets/img/typescript/figura24.png" alt="">
    <caption><strong>Figura 24.</strong> Cambio del orden de las variables dentro de la desestructuración</caption>

    <li>¿Es posible asignar una variable al literal del vector que no fuera la primera posición? En este caso hubiera sido necesario omitir las posiciones anteriores anteriores del vector (figura 25)</li>
    <li>Como se observa en esta figura, hemos asignado la variable <i>apellidos</i> al literal de la segunda posición del vector, lo que requiere omitir las posiciones anteriores (en este caso, la primera)</li>
    <li>Nótese que no fue necesario omitir las siguientes posiciones escribiendo comas, no hace falta, solo es necesario hacerlos con las posiciones anteriores, no con las posteriores</li>
    <li>Tras esto asignamos las variables <i>edad</i> y <i>profesion</i> a los literales de las dos últimas posiciones para ilustrar que es posible hacer esto con más de una variable</li>

    <img src="assets/img/typescript/figura25.png" alt="">
    <caption><strong>Figura 25.</strong> Omisión de variables en la desestructuración de un vector</caption>
  </ul>

  <h3 id="promesas">7. Promesas</h3>
  <hr>

  <ul>
    <li>Las promesas son una prestación de ES6 que permite ejecutar código tras la finalización de una tarea asíncrona</li>
    <li>En la figura 26 podemos ver la sintaxis general de una promesa, en la que la tarea asíncrosa es <b>setTimeout()</b>, pero que bien pudiera haber sido cualquier otra</li>
    <li>Las funciones <b>resolve()</b> y <b>reject()</b> se ejecutarán en función de si la promesa finaliza su ejecución bien o mal, respectivamente</li>
    <li>Estos identificadores son un estándar, pero las hubiéramos podido nombrar de cualquier otra forma</li>
    <li>Lo que importa es que la función que se ejecute si todo fue bien sea la que escribamos en primer lugar como parámetro y la otra en segundo lugar</li>

    <img src="assets/img/typescript/figura26.png" alt="">
    <caption><strong>Figura 26.</strong> Cuepro de una promesa</caption>

    <li>En la figura 27 se invoca la promesa de la figura 26. Nótese que la invocación se divide en dos partes: el cuerpo de la función <b>resolve()</b> en primer lugar y el de la función <b>reject()</b> en segundo lugar</li>

    <img src="assets/img/typescript/figura27.png" alt="">
    <caption><strong>Figura 27.</strong> Invocación de una promesa</caption>

    <li>La figura 28 ilustra la inesperada salida por consola tras la ejecución del código de la figura 27</li>
    <li>¿Por qué los mensajes aparecen desordenados? Porque la promesa encierra código asíncrono (en este caso, la función <b>setTimeout()</b>)</li>
    <li>Esto significa que el código que se encuentre después de código asíncrono se ejecutará tanto si este último ha finalizado su ejecución como si no</li>
    <li>Claro, eso explica que el segundo mensaje en aparecer sea <i>Paso 2</i>, dado que la instrucción inherente a esta salida no esperó a que la promesa finalizara su ejecución</li>
    <li>Tras esto, mientras se ejecuta el código que se encuentra dentro del cuerpo de la promesa (figura 26), no se espera a que la función <b>setTimeout()</b> finalice</li>
    <li>En su lugar ejecuta primero el código de la función <b>resolve()</b> tras ser invocada, lo que explica la salida <i>La ejecución finalizó sin errores</i> antes de la salida <i>Ejecución finalizada</i></li>

    <img src="assets/img/typescript/figura28.png" alt="">
    <caption><strong>Figura 28.</strong> Salida de la consola tras la ejecución del código de la figura 27</caption>
  </ul>

  <h3 id="interfaces">8. Interfaces</h3>
  <hr>

  <ul>
    <li></li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3>Observable</h3>
  <hr>

  <ul>
    <li>Un observable es similar a una promesa</li>
    <li>Los métodos de un servicio HTTP son observables</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3>Suscripción</h3>
  <hr>

  <ul>
    <li>Cuando deseamos utilizar el método de un servicio (un observable), debemos suscribirnos</li>
  </ul>

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 class="hidden">Programación reactiva</h3>
  <hr class="hidden">

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 class="hidden">Operadorex RXJS</h3>
  <hr class="hidden">

  <!-- ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── -->

  <h3 class="hidden">Inyección</h3>
  <hr class="hidden">

</div>